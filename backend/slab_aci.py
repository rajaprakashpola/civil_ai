# slab_aci.py
"""
Simple ACI one-way slab design (plug-and-play)
Units:
 - span_m: meters
 - thickness_mm, cover_mm, bar_dia_mm, spacing in mm
 - loads: kN/m^2
 - fc_MPa, fy_MPa in MPa
Outputs: dataclass SlabACIResult and JSON-like dict via run_slab_design()
Also writes a small HTML and TXT report to `reports/`
"""

from dataclasses import dataclass, asdict
from math import pi
import math
import time
import os
import json

# ----------------------------
# Input / Output dataclasses
# ----------------------------
@dataclass
class SlabACIInput:
    span_m: float
    thickness_mm: float
    dl_kN_per_m2: float
    ll_kN_per_m2: float
    fc_MPa: float
    fy_MPa: float
    cover_mm: float = 20          # default cover
    bar_dia_mm: int = 10         # default design bar diameter to use when calculating spacing

@dataclass
class SlabACIResult:
    Mu_kNm: float
    effective_depth_mm: float
    required_As_mm2_per_m: float
    provided_As_mm2_per_m: float
    bar_dia_mm: int
    spacing_mm: int
    utilization_percent: float
    notes: dict

# ----------------------------
# Core design function
# ----------------------------
def design_aci_slab(data: SlabACIInput) -> SlabACIResult:
    """
    Simplified ACI one-way slab flexure design per meter width.
    """
    bar_dia = float(data.bar_dia_mm)
    cover = float(data.cover_mm)
    d = float(data.thickness_mm) - cover - (bar_dia / 2.0)
    if d <= 0:
        raise ValueError("Effective depth <= 0. Increase slab thickness or reduce cover/bar size.")

    # Factored load w_u (kN/m^2)
    w_u = 1.2 * float(data.dl_kN_per_m2) + 1.6 * float(data.ll_kN_per_m2)

    # Factored moment Mu for simply supported strip (per meter width): Mu = wL^2 / 8
    Mu_kNm = w_u * (float(data.span_m) ** 2) / 8.0  # kN·m per meter width

    # Convert to N·mm for reinforcing calc
    Mu_Nmm = Mu_kNm * 1e6

    # Lever arm approximation jd ≈ 0.9*d (mm)
    jd = 0.9 * d
    if jd <= 0:
        raise ValueError("Calculated lever arm non-positive. Check inputs.")

    # Required steel area As_req (mm^2 per meter width)
    As_req_mm2_per_m = Mu_Nmm / (0.87 * float(data.fy_MPa) * jd)

    # Minimum steel As_min per ACI (practical default for slab = 0.0018 * b * d) per meter width (b=1000mm)
    As_min_mm2_per_m = 0.0018 * 1000.0 * d

    required_As_final = max(As_req_mm2_per_m, As_min_mm2_per_m)

    # Area of one bar (mm^2)
    area_bar_mm2 = (math.pi * (bar_dia ** 2)) / 4.0

    # Spacing calculation
    raw_spacing = (area_bar_mm2 * 1000.0) / required_As_final
    spacing_mm = int(max(75, min(300, round(raw_spacing))))
    provided_As_mm2_per_m = (area_bar_mm2 * 1000.0) / spacing_mm

    utilization = (required_As_final / provided_As_mm2_per_m) * 100.0 if provided_As_mm2_per_m > 0 else 999.9

    notes = {
        "w_u_kN_per_m2": round(w_u, 3),
        "Mu_kNm_per_m": round(Mu_kNm, 4),
        "As_req_mm2_per_m_raw": round(As_req_mm2_per_m, 3),
        "As_min_mm2_per_m": round(As_min_mm2_per_m, 3),
        "raw_spacing_mm": round(raw_spacing, 2),
    }

    return SlabACIResult(
        Mu_kNm = round(Mu_kNm, 4),
        effective_depth_mm = round(d, 2),
        required_As_mm2_per_m = round(required_As_final, 3),
        provided_As_mm2_per_m = round(provided_As_mm2_per_m, 3),
        bar_dia_mm = int(bar_dia),
        spacing_mm = int(spacing_mm),
        utilization_percent = round(utilization, 2),
        notes = notes
    )

# ----------------------------
# Wrapper + report writer
# ----------------------------
def _ensure_reports_folder():
    folder = os.path.join(os.getcwd(), "reports")
    os.makedirs(folder, exist_ok=True)
    return folder

def _write_reports(module_name: str, params: dict, result: SlabACIResult):
    folder = _ensure_reports_folder()
    ts = time.strftime("%Y%m%d_%H%M%S")
    base = f"{module_name}_report_{ts}"
    txt_path = os.path.join(folder, base + ".txt")
    html_path = os.path.join(folder, base + ".html")

    # TXT report
    with open(txt_path, "w") as f:
        f.write("=== SLAB DESIGN REPORT ===\n")
        f.write(f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        f.write("INPUTS:\n")
        f.write(json.dumps(params, indent=2))
        f.write("\n\nRESULTS:\n")
        f.write(json.dumps(asdict(result), indent=2))
        f.write("\n")

    # Simple HTML report
    html = f"""
    <html>
    <head><meta charset="utf-8"><title>Slab Report</title></head>
    <body style="font-family:Arial,Helvetica,sans-serif;padding:16px;">
      <h2>SLAB DESIGN REPORT</h2>
      <p><strong>Timestamp:</strong> {time.strftime('%Y-%m-%d %H:%M:%S')}</p>
      <h3>Inputs</h3>
      <pre>{json.dumps(params, indent=2)}</pre>
      <h3>Results</h3>
      <pre>{json.dumps(asdict(result), indent=2)}</pre>
      <hr/>
      <small>Generated by slab_aci.py (simple ACI one-way slab design)</small>
    </body>
    </html>
    """
    with open(html_path, "w") as f:
        f.write(html)

    return {"txt": txt_path, "html": html_path}

def run_slab_design(params: dict, write_reports: bool = True) -> dict:
    """
    params: dictionary matching SlabACIInput field names.
    returns: dict with meta, inputs, results, report_paths (if write_reports=True)
    """
    normalized = {}
    for k, v in params.items():
        # try robust float conversion, preserve None
        if v is None:
            normalized[k] = v
            continue
        try:
            normalized[k] = float(v)
        except Exception:
            normalized[k] = v

    slab_input = SlabACIInput(**normalized)
    result = design_aci_slab(slab_input)

    out = {
        "meta": {"module": "slab_aci", "code": "ACI", "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")},
        "inputs": asdict(slab_input),
        "results": asdict(result)
    }

    if write_reports:
        paths = _write_reports("slab", out["inputs"], result)
        out["report_paths"] = paths

    return out

# Quick CLI test
if __name__ == "__main__":
    sample_params = {
        "span_m": 3.0,
        "thickness_mm": 150,
        "dl_kN_per_m2": 5.0,
        "ll_kN_per_m2": 3.0,
        "fc_MPa": 30.0,
        "fy_MPa": 420.0,
        "cover_mm": 20,
        "bar_dia_mm": 10
    }
    res = run_slab_design(sample_params)
    print(json.dumps(res, indent=2))
    print("\nReports saved at:", res.get("report_paths"))